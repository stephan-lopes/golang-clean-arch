
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stephan-lopes/golang-clean-arch/adapter/http/main.go (0.0%)</option>
				
				<option value="file1">github.com/stephan-lopes/golang-clean-arch/adapter/http/productservice/create.go (100.0%)</option>
				
				<option value="file2">github.com/stephan-lopes/golang-clean-arch/adapter/http/productservice/fetch.go (100.0%)</option>
				
				<option value="file3">github.com/stephan-lopes/golang-clean-arch/adapter/http/productservice/new.go (100.0%)</option>
				
				<option value="file4">github.com/stephan-lopes/golang-clean-arch/adapter/postgres/connector.go (0.0%)</option>
				
				<option value="file5">github.com/stephan-lopes/golang-clean-arch/adapter/postgres/productrepository/create.go (100.0%)</option>
				
				<option value="file6">github.com/stephan-lopes/golang-clean-arch/adapter/postgres/productrepository/fetch.go (100.0%)</option>
				
				<option value="file7">github.com/stephan-lopes/golang-clean-arch/adapter/postgres/productrepository/new.go (100.0%)</option>
				
				<option value="file8">github.com/stephan-lopes/golang-clean-arch/core/domain/usecase/productusecase/create.go (100.0%)</option>
				
				<option value="file9">github.com/stephan-lopes/golang-clean-arch/core/domain/usecase/productusecase/fetch.go (100.0%)</option>
				
				<option value="file10">github.com/stephan-lopes/golang-clean-arch/core/domain/usecase/productusecase/new.go (100.0%)</option>
				
				<option value="file11">github.com/stephan-lopes/golang-clean-arch/core/dto/pagination.go (100.0%)</option>
				
				<option value="file12">github.com/stephan-lopes/golang-clean-arch/core/dto/product.go (100.0%)</option>
				
				<option value="file13">github.com/stephan-lopes/golang-clean-arch/di/product.go (0.0%)</option>
				
				<option value="file14">github.com/stephan-lopes/golang-clean-arch/test/mock/dbmock.go (100.0%)</option>
				
				<option value="file15">github.com/stephan-lopes/golang-clean-arch/test/mock/fakeproduct.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"

        "github.com/gorilla/mux"
        "github.com/spf13/viper"
        "github.com/stephan-lopes/golang-clean-arch/adapter/postgres"
        "github.com/stephan-lopes/golang-clean-arch/di"
)

func init() {<span class="cov0" title="0">}</span>

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        conn := postgres.GetConnection(ctx)
        defer conn.Close()

        postgres.RunMigration()
        productService := di.ConfigProductDI(conn)

        router := mux.NewRouter()
        router.Handle("/product", http.HandlerFunc(productService.Create)).Methods("POST")
        router.Handle("/product", http.HandlerFunc(productService.Fetch)).Queries(
                "page", "{page}",
                "itemsPerPage", "{itemsPerPage}",
                "descending", "{descending}",
                "sort", "{sort}",
                "search", "{search}",
        ).Methods("GET")

        port := viper.GetString("server.port")
        log.Printf("Listen on Port: %v", port)
        http.ListenAndServe(fmt.Sprintf(":%v", port), router)

}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package productservice

import (
        "encoding/json"
        "net/http"

        "github.com/stephan-lopes/golang-clean-arch/core/dto"
)

func (service service) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        productRequest, err := dto.FromJSONCreateProductRequest(r.Body)

        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(500)
                w.Write([]byte(err.Error()))
                return
        }</span>

        <span class="cov8" title="1">product, err := service.usecase.Create(productRequest)

        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(500)
                w.Write([]byte(err.Error()))
                return
        }</span>

        <span class="cov8" title="1">json.NewEncoder(w).Encode(product)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package productservice

import (
        "encoding/json"
        "net/http"

        "github.com/stephan-lopes/golang-clean-arch/core/dto"
)

func (service service) Fetch(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationRequest, _ := dto.FromValuePaginationRequestParams(r)

        products, err := service.usecase.Fetch(paginationRequest)
        if err != nil </span><span class="cov8" title="1">{
                w.WriteHeader(500)
                w.Write([]byte(err.Error()))
                return
        }</span>

        <span class="cov8" title="1">json.NewEncoder(w).Encode(products)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package productservice

import "github.com/stephan-lopes/golang-clean-arch/core/domain"

type service struct {
        usecase domain.ProductUseCase
}

func New(usecase domain.ProductUseCase) domain.ProductService <span class="cov8" title="1">{
        return &amp;service{
                usecase: usecase,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package postgres

import (
        "context"
        "fmt"
        "log"
        "os"

        "github.com/golang-migrate/migrate/v4"
        "github.com/jackc/pgconn"
        "github.com/jackc/pgx/v4"
        "github.com/jackc/pgx/v4/pgxpool"
        "github.com/spf13/viper"
)

// Wrapping do pgxpool para criar mock para os testes
type PoolInterface interface {
        Close()
        Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
        QueryFunc(context.Context, string, []interface{}, []interface{}, func(pgx.QueryFuncRow) error) (pgconn.CommandTag, error)
        SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults
        Begin(ctx context.Context) (pgx.Tx, error)
        BeginFunc(ctx context.Context, f func(pgx.Tx) error) error
        BeginTxFunc(ctx context.Context, txOptions pgx.TxOptions, f func(pgx.Tx) error) error
}

func GetConnection(context context.Context) *pgxpool.Pool <span class="cov0" title="0">{
        databaseURL := viper.GetString("database.url")

        conn, err := pgxpool.Connect(context, "postgres"+databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">return conn</span>
}

func RunMigration() <span class="cov0" title="0">{
        databaseURL := viper.GetString("database.url")
        m, err := migrate.New("file://database/migrations", "pgx"+databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package productrepository

import (
        "context"

        "github.com/stephan-lopes/golang-clean-arch/core/domain"
        "github.com/stephan-lopes/golang-clean-arch/core/dto"
)

func (repository repository) Create(productRequest *dto.CreateProductRequest) (*domain.Product, error) <span class="cov8" title="1">{
        ctx := context.Background()
        product := domain.Product{}

        err := repository.db.QueryRow(
                ctx,
                "INSERT INTO product (name, price, description) VALUES ($1, $2, $3) returning *",
                productRequest.Name,
                productRequest.Price,
                productRequest.Description,
        ).Scan(
                &amp;product.ID,
                &amp;product.Name,
                &amp;product.Price,
                &amp;product.Description,
        )

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;product, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package productrepository

import (
        "context"

        "github.com/booscaaa/go-paginate/paginate"
        "github.com/stephan-lopes/golang-clean-arch/core/domain"
        "github.com/stephan-lopes/golang-clean-arch/core/dto"
)

func (repository repository) Fetch(paginationRequest *dto.PaginationRequestParams) (*domain.Pagination[[]domain.Product], error) <span class="cov8" title="1">{
        ctx := context.Background()
        products := []domain.Product{}
        total := int32(0)
        pager := paginate.Instance("")

        query, queryCount := pager.
                Query("SELECT * FROM product").
                Page(paginationRequest.Page).
                Desc(paginationRequest.Descending).
                Sort(paginationRequest.Sort).
                RowsPerPage(paginationRequest.ItemsPerPage).
                SearchBy(paginationRequest.Search, "name", "description").
                Select()

        rows, err := repository.db.Query(
                ctx,
                *query,
        )

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                product := domain.Product{}

                rows.Scan(
                        &amp;product.ID,
                        &amp;product.Name,
                        &amp;product.Price,
                        &amp;product.Description,
                )

                products = append(products, product)
        }</span>

        <span class="cov8" title="1">err = repository.db.QueryRow(ctx, *queryCount).Scan(&amp;total)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;domain.Pagination[[]domain.Product]{
                Items: products,
                Total: total,
        }, nil</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package productrepository

import (
        "github.com/stephan-lopes/golang-clean-arch/adapter/postgres"
        "github.com/stephan-lopes/golang-clean-arch/core/domain"
)

type repository struct {
        db postgres.PoolInterface
}

func New(db postgres.PoolInterface) domain.ProductRepository <span class="cov8" title="1">{
        return &amp;repository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package productusecase

import (
        "github.com/stephan-lopes/golang-clean-arch/core/domain"
        "github.com/stephan-lopes/golang-clean-arch/core/dto"
)

func (usecase usecase) Create(productRequest *dto.CreateProductRequest) (*domain.Product, error) <span class="cov8" title="1">{
        product, err := usecase.repository.Create(productRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return product, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package productusecase

import (
        "github.com/stephan-lopes/golang-clean-arch/core/domain"
        "github.com/stephan-lopes/golang-clean-arch/core/dto"
)

func (usecase usecase) Fetch(paginationRequest *dto.PaginationRequestParams) (*domain.Pagination[[]domain.Product], error) <span class="cov8" title="1">{
        products, err := usecase.repository.Fetch(paginationRequest)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return products, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package productusecase

import "github.com/stephan-lopes/golang-clean-arch/core/domain"

type usecase struct {
        repository domain.ProductRepository
}

func New(repository domain.ProductRepository) domain.ProductUseCase <span class="cov8" title="1">{
        return &amp;usecase{
                repository: repository,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package dto

import (
        "net/http"
        "strconv"
        "strings"
)

type PaginationRequestParams struct {
        Search       string   `json:"search"`
        Descending   []string `json:"descending"`
        Page         int      `json:"page"`
        ItemsPerPage int      `json:"itemsPerPage"`
        Sort         []string `json:"sort"`
}

func FromValuePaginationRequestParams(request *http.Request) (*PaginationRequestParams, error) <span class="cov8" title="1">{
        page, _ := strconv.Atoi(request.FormValue("page"))
        itemsPerPage, _ := strconv.Atoi(request.FormValue("itemsPerPage"))

        paginationRequestParams := PaginationRequestParams{
                Search:       request.FormValue("search"),
                Descending:   strings.Split(request.FormValue("descending"), ","),
                Sort:         strings.Split(request.FormValue("sort"), ","),
                Page:         page,
                ItemsPerPage: itemsPerPage,
        }

        return &amp;paginationRequestParams, nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package dto

import (
        "encoding/json"
        "io"
)

type CreateProductRequest struct {
        Name        string  `json:"name"`
        Price       float32 `json:"price"`
        Description string  `json:"description"`
}

func FromJSONCreateProductRequest(body io.Reader) (*CreateProductRequest, error) <span class="cov8" title="1">{
        createProductRequest := CreateProductRequest{}
        if err := json.NewDecoder(body).Decode(&amp;createProductRequest); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;createProductRequest, nil</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">package di

import (
        "github.com/stephan-lopes/golang-clean-arch/adapter/http/productservice"
        "github.com/stephan-lopes/golang-clean-arch/adapter/postgres"
        "github.com/stephan-lopes/golang-clean-arch/adapter/postgres/productrepository"
        "github.com/stephan-lopes/golang-clean-arch/core/domain"
        "github.com/stephan-lopes/golang-clean-arch/core/domain/usecase/productusecase"
)

func ConfigProductDI(conn postgres.PoolInterface) domain.ProductService <span class="cov0" title="0">{
        productRepository := productrepository.New(conn)
        productUseCase := productusecase.New(productRepository)
        productService := productservice.New(productUseCase)

        return productService
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package mock

import (
        "github.com/go-faker/faker/v4"
        "github.com/pashagolub/pgxmock"
        "github.com/stephan-lopes/golang-clean-arch/core/domain"
        "github.com/stephan-lopes/golang-clean-arch/core/dto"
)

func NewDBSetupCreate() ([]string, dto.CreateProductRequest, domain.Product, pgxmock.PgxPoolIface) <span class="cov8" title="1">{
        cols := []string{"id", "name", "price", "description"}
        fakeProductRequest := dto.CreateProductRequest{}
        fakeProductDBResponse := domain.Product{}
        faker.FakeData(&amp;fakeProductRequest)
        faker.FakeData(&amp;fakeProductDBResponse)

        mock, _ := pgxmock.NewPool()

        return cols, fakeProductRequest, fakeProductDBResponse, mock
}</span>

func NewDBSetupFetch() ([]string, dto.PaginationRequestParams, domain.Product, pgxmock.PgxPoolIface) <span class="cov8" title="1">{
        cols := []string{"id", "name", "price", "description"}
        fakePaginationRequestParams := dto.PaginationRequestParams{
                Page:         1,
                ItemsPerPage: 10,
                Sort:         nil,
                Descending:   nil,
                Search:       "",
        }
        fakeProductDBResponse := domain.Product{}
        faker.FakeData(&amp;fakeProductDBResponse)

        mock, _ := pgxmock.NewPool()

        return cols, fakePaginationRequestParams, fakeProductDBResponse, mock
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: core/domain/product.go
//
// Generated by this command:
//
//        mockgen -source=core/domain/product.go -destination=test/mock/fakeproduct.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mock

import (
        http "net/http"
        reflect "reflect"

        domain "github.com/stephan-lopes/golang-clean-arch/core/domain"
        dto "github.com/stephan-lopes/golang-clean-arch/core/dto"
        gomock "go.uber.org/mock/gomock"
)

// MockProductService is a mock of ProductService interface.
type MockProductService struct {
        ctrl     *gomock.Controller
        recorder *MockProductServiceMockRecorder
}

// MockProductServiceMockRecorder is the mock recorder for MockProductService.
type MockProductServiceMockRecorder struct {
        mock *MockProductService
}

// NewMockProductService creates a new mock instance.
func NewMockProductService(ctrl *gomock.Controller) *MockProductService <span class="cov0" title="0">{
        mock := &amp;MockProductService{ctrl: ctrl}
        mock.recorder = &amp;MockProductServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProductService) EXPECT() *MockProductServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockProductService) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Create", w, r)
}</span>

// Create indicates an expected call of Create.
func (mr *MockProductServiceMockRecorder) Create(w, r any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockProductService)(nil).Create), w, r)
}</span>

// Fetch mocks base method.
func (m *MockProductService) Fetch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Fetch", w, r)
}</span>

// Fetch indicates an expected call of Fetch.
func (mr *MockProductServiceMockRecorder) Fetch(w, r any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockProductService)(nil).Fetch), w, r)
}</span>

// MockProductUseCase is a mock of ProductUseCase interface.
type MockProductUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockProductUseCaseMockRecorder
}

// MockProductUseCaseMockRecorder is the mock recorder for MockProductUseCase.
type MockProductUseCaseMockRecorder struct {
        mock *MockProductUseCase
}

// NewMockProductUseCase creates a new mock instance.
func NewMockProductUseCase(ctrl *gomock.Controller) *MockProductUseCase <span class="cov8" title="1">{
        mock := &amp;MockProductUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockProductUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProductUseCase) EXPECT() *MockProductUseCaseMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockProductUseCase) Create(productRequest *dto.CreateProductRequest) (*domain.Product, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", productRequest)
        ret0, _ := ret[0].(*domain.Product)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockProductUseCaseMockRecorder) Create(productRequest any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockProductUseCase)(nil).Create), productRequest)
}</span>

// Fetch mocks base method.
func (m *MockProductUseCase) Fetch(paginationRequest *dto.PaginationRequestParams) (*domain.Pagination[[]domain.Product], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Fetch", paginationRequest)
        ret0, _ := ret[0].(*domain.Pagination[[]domain.Product])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Fetch indicates an expected call of Fetch.
func (mr *MockProductUseCaseMockRecorder) Fetch(paginationRequest any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockProductUseCase)(nil).Fetch), paginationRequest)
}</span>

// MockProductRepository is a mock of ProductRepository interface.
type MockProductRepository struct {
        ctrl     *gomock.Controller
        recorder *MockProductRepositoryMockRecorder
}

// MockProductRepositoryMockRecorder is the mock recorder for MockProductRepository.
type MockProductRepositoryMockRecorder struct {
        mock *MockProductRepository
}

// NewMockProductRepository creates a new mock instance.
func NewMockProductRepository(ctrl *gomock.Controller) *MockProductRepository <span class="cov8" title="1">{
        mock := &amp;MockProductRepository{ctrl: ctrl}
        mock.recorder = &amp;MockProductRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProductRepository) EXPECT() *MockProductRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockProductRepository) Create(productRequest *dto.CreateProductRequest) (*domain.Product, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", productRequest)
        ret0, _ := ret[0].(*domain.Product)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockProductRepositoryMockRecorder) Create(productRequest any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockProductRepository)(nil).Create), productRequest)
}</span>

// Fetch mocks base method.
func (m *MockProductRepository) Fetch(paginationRequest *dto.PaginationRequestParams) (*domain.Pagination[[]domain.Product], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Fetch", paginationRequest)
        ret0, _ := ret[0].(*domain.Pagination[[]domain.Product])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Fetch indicates an expected call of Fetch.
func (mr *MockProductRepositoryMockRecorder) Fetch(paginationRequest any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockProductRepository)(nil).Fetch), paginationRequest)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
